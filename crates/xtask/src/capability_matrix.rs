use std::{
    collections::{BTreeMap, BTreeSet},
    fs,
    path::{Path, PathBuf},
};

use agent_api::{
    backends::{
        claude_code::{ClaudeCodeBackend, ClaudeCodeBackendConfig},
        codex::{CodexBackend, CodexBackendConfig},
    },
    AgentWrapperBackend, AgentWrapperCapabilities,
};
use clap::Parser;

#[derive(Debug, Parser)]
pub struct Args {
    /// Write the generated markdown to this path.
    #[arg(
        long,
        default_value = "docs/specs/universal-agent-api/capability-matrix.md"
    )]
    pub out: PathBuf,
}

pub fn run(args: Args) -> Result<(), String> {
    let backends = collect_builtin_backend_capabilities();
    let markdown = render_matrix(&backends);
    write_file(&args.out, &markdown)?;
    Ok(())
}

pub(crate) fn collect_builtin_backend_capabilities() -> BTreeMap<String, AgentWrapperCapabilities> {
    let mut backends = BTreeMap::<String, AgentWrapperCapabilities>::new();

    let codex = CodexBackend::new(CodexBackendConfig::default());
    backends.insert(codex.kind().as_str().to_string(), codex.capabilities());

    let claude = ClaudeCodeBackend::new(ClaudeCodeBackendConfig::default());
    backends.insert(claude.kind().as_str().to_string(), claude.capabilities());

    backends
}

fn write_file(path: &Path, contents: &str) -> Result<(), String> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).map_err(|err| format!("create_dir_all({path:?}): {err}"))?;
    }
    fs::write(path, contents).map_err(|err| format!("write({path:?}): {err}"))?;
    Ok(())
}

fn render_matrix(backends: &BTreeMap<String, AgentWrapperCapabilities>) -> String {
    let backend_ids: Vec<String> = backends.keys().cloned().collect();

    let mut all_caps = BTreeSet::<String>::new();
    for caps in backends.values() {
        all_caps.extend(caps.ids.iter().cloned());
    }

    let mut buckets = BTreeMap::<String, Vec<String>>::new();
    for cap in all_caps {
        let bucket = bucket_for(&cap);
        buckets.entry(bucket).or_default().push(cap);
    }

    for caps in buckets.values_mut() {
        caps.sort();
        caps.dedup();
    }

    let mut out = String::new();
    out.push_str("# Capability matrix — Universal Agent API\n\n");
    out.push_str("Status: Approved  \n");
    out.push_str("Approved (UTC): 2026-02-21\n\n");
    out.push_str("This file is generated by `cargo run -p xtask -- capability-matrix`.\n");
    out.push_str("Do not edit by hand.\n\n");

    let bucket_order = bucket_order(&backend_ids);
    for bucket in bucket_order {
        let Some(cap_ids) = buckets.get(&bucket) else {
            continue;
        };
        if cap_ids.is_empty() {
            continue;
        }

        out.push_str(&format!("## `{bucket}`\n\n"));
        out.push_str("| capability id |");
        for backend_id in backend_ids.iter() {
            out.push_str(&format!(" `{backend_id}` |"));
        }
        out.push('\n');

        out.push_str("|---|");
        for _ in backend_ids.iter() {
            out.push_str("---|");
        }
        out.push('\n');

        for cap_id in cap_ids.iter() {
            out.push_str(&format!("| `{cap_id}` |"));
            for backend_id in backend_ids.iter() {
                let supported = backends
                    .get(backend_id)
                    .is_some_and(|caps| caps.contains(cap_id));
                out.push_str(if supported { " ✅ |" } else { " — |" });
            }
            out.push('\n');
        }
        out.push('\n');
    }

    out
}

fn bucket_for(capability_id: &str) -> String {
    if capability_id == "agent_api.run" || capability_id == "agent_api.events" {
        return "agent_api.core".to_string();
    }

    if capability_id == "agent_api.events" || capability_id.starts_with("agent_api.events.") {
        return "agent_api.events".to_string();
    }

    if capability_id.starts_with("agent_api.exec.") {
        return "agent_api.exec".to_string();
    }

    for prefix in [
        "agent_api.tools.",
        "agent_api.artifacts.",
        "agent_api.control.",
        "agent_api.config.",
        "agent_api.obs.",
    ] {
        if capability_id.starts_with(prefix) {
            let bucket = prefix.trim_end_matches('.');
            return bucket.to_string();
        }
    }

    if capability_id.starts_with("agent_api.") {
        return "agent_api.other".to_string();
    }

    if let Some(agent_kind) = capability_id.strip_prefix("backend.") {
        let agent_kind = agent_kind
            .split_once('.')
            .map(|(head, _)| head)
            .unwrap_or(agent_kind);
        return format!("backend.{agent_kind}");
    }

    "other".to_string()
}

fn bucket_order(backend_ids: &[String]) -> Vec<String> {
    let mut out = Vec::new();
    out.extend([
        "agent_api.core".to_string(),
        "agent_api.events".to_string(),
        "agent_api.exec".to_string(),
        "agent_api.tools".to_string(),
        "agent_api.artifacts".to_string(),
        "agent_api.control".to_string(),
        "agent_api.config".to_string(),
        "agent_api.obs".to_string(),
        "agent_api.other".to_string(),
    ]);

    let mut backend_buckets: Vec<String> = backend_ids
        .iter()
        .map(|id| format!("backend.{id}"))
        .collect();
    backend_buckets.sort();
    backend_buckets.dedup();
    out.extend(backend_buckets);

    out.push("other".to_string());
    out
}
