diff --git a/crates/codex/src/builder.rs b/crates/codex/src/builder.rs
new file mode 100644
index 0000000..25c250e
--- /dev/null
+++ b/crates/codex/src/builder.rs
@@ -0,0 +1,921 @@
+use std::{
+    ffi::OsString,
+    path::PathBuf,
+    time::Duration,
+};
+
+use tokio::process::Command;
+
+use crate::home::CommandEnvironment;
+
+pub(super) const DEFAULT_REASONING_CONFIG_GPT5: &[(&str, &str)] = &[
+    ("model_reasoning_effort", "medium"),
+    ("model_reasoning_summary", "auto"),
+    ("model_verbosity", "low"),
+];
+
+pub(super) const DEFAULT_REASONING_CONFIG_GPT5_CODEX: &[(&str, &str)] = &[
+    ("model_reasoning_effort", "medium"),
+    ("model_reasoning_summary", "auto"),
+    ("model_verbosity", "low"),
+];
+
+pub(super) const DEFAULT_REASONING_CONFIG_GPT5_1: &[(&str, &str)] = &[
+    ("model_reasoning_effort", "medium"),
+    ("model_reasoning_summary", "auto"),
+    ("model_verbosity", "low"),
+];
+
+/// Builder for [`crate::CodexClient`].
+///
+/// CLI parity planning and implementation history lives under `docs/project_management/next/`
+/// (see `docs/project_management/next/codex-cli-parity/`) and the parity ADRs in `docs/adr/`.
+#[derive(Clone, Debug)]
+pub struct CodexClientBuilder {
+    pub(super) binary: PathBuf,
+    pub(super) codex_home: Option<PathBuf>,
+    pub(super) create_home_dirs: bool,
+    pub(super) model: Option<String>,
+    pub(super) timeout: Duration,
+    pub(super) color_mode: ColorMode,
+    pub(super) working_dir: Option<PathBuf>,
+    pub(super) add_dirs: Vec<PathBuf>,
+    pub(super) images: Vec<PathBuf>,
+    pub(super) json_output: bool,
+    pub(super) output_schema: bool,
+    pub(super) quiet: bool,
+    pub(super) mirror_stdout: bool,
+    pub(super) json_event_log: Option<PathBuf>,
+    pub(super) cli_overrides: CliOverrides,
+    pub(super) capability_overrides: crate::CapabilityOverrides,
+    pub(super) capability_cache_policy: crate::CapabilityCachePolicy,
+}
+
+impl CodexClientBuilder {
+    /// Starts a new builder with default values.
+    pub fn new() -> Self {
+        Self::default()
+    }
+
+    /// Sets the path to the Codex binary.
+    ///
+    /// Defaults to `CODEX_BINARY` when present or `codex` on `PATH`. Use this to pin a packaged
+    /// binary, e.g. the path returned from [`crate::resolve_bundled_binary`] when your app ships Codex
+    /// inside an isolated bundle.
+    pub fn binary(mut self, binary: impl Into<PathBuf>) -> Self {
+        self.binary = binary.into();
+        self
+    }
+
+    /// Sets a custom `CODEX_HOME` path that will be applied per command.
+    /// Directories are created by default; disable via [`Self::create_home_dirs`].
+    pub fn codex_home(mut self, home: impl Into<PathBuf>) -> Self {
+        self.codex_home = Some(home.into());
+        self
+    }
+
+    /// Controls whether the CODEX_HOME directory tree should be created if missing.
+    /// Defaults to `true` when [`Self::codex_home`] is set.
+    pub fn create_home_dirs(mut self, enable: bool) -> Self {
+        self.create_home_dirs = enable;
+        self
+    }
+
+    /// Sets the model that should be used for every `codex exec` call.
+    pub fn model(mut self, model: impl Into<String>) -> Self {
+        let model = model.into();
+        self.model = (!model.trim().is_empty()).then_some(model);
+        self
+    }
+
+    /// Overrides the maximum amount of time to wait for Codex to respond.
+    pub fn timeout(mut self, timeout: Duration) -> Self {
+        self.timeout = timeout;
+        self
+    }
+
+    /// Controls whether Codex may emit ANSI colors (`--color`). Defaults to [`ColorMode::Never`].
+    pub fn color_mode(mut self, color_mode: ColorMode) -> Self {
+        self.color_mode = color_mode;
+        self
+    }
+
+    /// Forces Codex to run with the provided working directory instead of a fresh temp dir.
+    pub fn working_dir(mut self, dir: impl Into<PathBuf>) -> Self {
+        self.working_dir = Some(dir.into());
+        self
+    }
+
+    /// Requests that `codex exec` include one or more `--add-dir` flags when the
+    /// probed binary supports them. Unsupported or unknown capability results
+    /// skip the flag to avoid CLI errors.
+    pub fn add_dir(mut self, path: impl Into<PathBuf>) -> Self {
+        self.add_dirs.push(path.into());
+        self
+    }
+
+    /// Replaces the current add-dir list with the provided collection.
+    pub fn add_dirs<I, P>(mut self, dirs: I) -> Self
+    where
+        I: IntoIterator<Item = P>,
+        P: Into<PathBuf>,
+    {
+        self.add_dirs = dirs.into_iter().map(Into::into).collect();
+        self
+    }
+
+    /// Adds an image to the prompt by passing `--image <path>` to `codex exec`.
+    pub fn image(mut self, path: impl Into<PathBuf>) -> Self {
+        self.images.push(path.into());
+        self
+    }
+
+    /// Replaces the current image list with the provided collection.
+    pub fn images<I, P>(mut self, images: I) -> Self
+    where
+        I: IntoIterator<Item = P>,
+        P: Into<PathBuf>,
+    {
+        self.images = images.into_iter().map(Into::into).collect();
+        self
+    }
+
+    /// Enables Codex's JSONL output mode (`--json`).
+    ///
+    /// Prompts are piped via stdin when enabled. Events include `thread.started`
+    /// (or `thread.resumed` when continuing), `turn.started`/`turn.completed`/`turn.failed`,
+    /// and `item.created`/`item.updated` with `item.type` such as `agent_message` or `reasoning`.
+    /// Pair with `.mirror_stdout(false)` if you plan to parse the stream instead of just mirroring it.
+    pub fn json(mut self, enable: bool) -> Self {
+        self.json_output = enable;
+        self
+    }
+
+    /// Requests the `--output-schema` flag when the probed binary reports
+    /// support. When capability detection is inconclusive, the flag is skipped
+    /// to maintain compatibility with older releases.
+    pub fn output_schema(mut self, enable: bool) -> Self {
+        self.output_schema = enable;
+        self
+    }
+
+    /// Suppresses mirroring Codex stderr to the console.
+    pub fn quiet(mut self, enable: bool) -> Self {
+        self.quiet = enable;
+        self
+    }
+
+    /// Controls whether Codex stdout should be mirrored to the console while
+    /// also being captured. Disable this when you plan to parse JSONL output or
+    /// tee the stream to a log file (see `crates/codex/examples/stream_with_log.rs`).
+    pub fn mirror_stdout(mut self, enable: bool) -> Self {
+        self.mirror_stdout = enable;
+        self
+    }
+
+    /// Tees each JSONL event line from [`crate::CodexClient::stream_exec`] into a log file.
+    /// Logs append to existing files, flush after each line, and create parent directories as
+    /// needed. [`crate::ExecStreamRequest::json_event_log`] overrides this default per request.
+    pub fn json_event_log(mut self, path: impl Into<PathBuf>) -> Self {
+        self.json_event_log = Some(path.into());
+        self
+    }
+
+    /// Adds a `--config key=value` override that will be applied to every Codex invocation.
+    pub fn config_override(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
+        self.cli_overrides
+            .config_overrides
+            .push(ConfigOverride::new(key, value));
+        self
+    }
+
+    /// Adds a preformatted `--config key=value` override without parsing the input.
+    pub fn config_override_raw(mut self, raw: impl Into<String>) -> Self {
+        self.cli_overrides
+            .config_overrides
+            .push(ConfigOverride::from_raw(raw));
+        self
+    }
+
+    /// Replaces the config overrides with the provided collection.
+    pub fn config_overrides<I, K, V>(mut self, overrides: I) -> Self
+    where
+        I: IntoIterator<Item = (K, V)>,
+        K: Into<String>,
+        V: Into<String>,
+    {
+        self.cli_overrides.config_overrides = overrides
+            .into_iter()
+            .map(|(key, value)| ConfigOverride::new(key, value))
+            .collect();
+        self
+    }
+
+    /// Selects a Codex config profile (`--profile`).
+    pub fn profile(mut self, profile: impl Into<String>) -> Self {
+        let profile = profile.into();
+        self.cli_overrides.profile = (!profile.trim().is_empty()).then_some(profile);
+        self
+    }
+
+    /// Sets `model_reasoning_effort` via `--config`.
+    pub fn reasoning_effort(mut self, effort: ReasoningEffort) -> Self {
+        self.cli_overrides.reasoning.effort = Some(effort);
+        self
+    }
+
+    /// Sets `model_reasoning_summary` via `--config`.
+    pub fn reasoning_summary(mut self, summary: ReasoningSummary) -> Self {
+        self.cli_overrides.reasoning.summary = Some(summary);
+        self
+    }
+
+    /// Sets `model_verbosity` via `--config`.
+    pub fn reasoning_verbosity(mut self, verbosity: ModelVerbosity) -> Self {
+        self.cli_overrides.reasoning.verbosity = Some(verbosity);
+        self
+    }
+
+    /// Sets `model_reasoning_summary_format` via `--config`.
+    pub fn reasoning_summary_format(mut self, format: ReasoningSummaryFormat) -> Self {
+        self.cli_overrides.reasoning.summary_format = Some(format);
+        self
+    }
+
+    /// Sets `model_supports_reasoning_summaries` via `--config`.
+    pub fn supports_reasoning_summaries(mut self, enable: bool) -> Self {
+        self.cli_overrides.reasoning.supports_summaries = Some(enable);
+        self
+    }
+
+    /// Controls whether GPT-5* reasoning defaults should be injected automatically.
+    pub fn auto_reasoning_defaults(mut self, enable: bool) -> Self {
+        self.cli_overrides.auto_reasoning_defaults = enable;
+        self
+    }
+
+    /// Sets the approval policy for Codex subprocesses.
+    pub fn approval_policy(mut self, policy: ApprovalPolicy) -> Self {
+        self.cli_overrides.approval_policy = Some(policy);
+        self
+    }
+
+    /// Sets the sandbox mode for Codex subprocesses.
+    pub fn sandbox_mode(mut self, mode: SandboxMode) -> Self {
+        self.cli_overrides.sandbox_mode = Some(mode);
+        self
+    }
+
+    /// Applies the `--full-auto` safety override unless explicit sandbox/approval options are set.
+    pub fn full_auto(mut self, enable: bool) -> Self {
+        self.cli_overrides.safety_override = if enable {
+            SafetyOverride::FullAuto
+        } else {
+            SafetyOverride::Inherit
+        };
+        self
+    }
+
+    /// Applies the `--dangerously-bypass-approvals-and-sandbox` override.
+    pub fn dangerously_bypass_approvals_and_sandbox(mut self, enable: bool) -> Self {
+        self.cli_overrides.safety_override = if enable {
+            SafetyOverride::DangerouslyBypass
+        } else {
+            SafetyOverride::Inherit
+        };
+        self
+    }
+
+    /// Applies `--cd <dir>` to Codex invocations while keeping the process cwd set to `working_dir`.
+    pub fn cd(mut self, dir: impl Into<PathBuf>) -> Self {
+        self.cli_overrides.cd = Some(dir.into());
+        self
+    }
+
+    /// Selects a local provider backend (`--local-provider`).
+    pub fn local_provider(mut self, provider: LocalProvider) -> Self {
+        self.cli_overrides.local_provider = Some(provider);
+        self
+    }
+
+    /// Requests the CLI `--oss` flag to favor OSS/local backends when available.
+    pub fn oss(mut self, enable: bool) -> Self {
+        self.cli_overrides.oss = if enable {
+            FlagState::Enable
+        } else {
+            FlagState::Disable
+        };
+        self
+    }
+
+    /// Adds a `--enable <feature>` toggle to Codex invocations.
+    pub fn enable_feature(mut self, name: impl Into<String>) -> Self {
+        self.cli_overrides.feature_toggles.enable.push(name.into());
+        self
+    }
+
+    /// Adds a `--disable <feature>` toggle to Codex invocations.
+    pub fn disable_feature(mut self, name: impl Into<String>) -> Self {
+        self.cli_overrides.feature_toggles.disable.push(name.into());
+        self
+    }
+
+    /// Controls whether `--search` is passed through to Codex.
+    pub fn search(mut self, enable: bool) -> Self {
+        self.cli_overrides.search = if enable {
+            FlagState::Enable
+        } else {
+            FlagState::Disable
+        };
+        self
+    }
+
+    /// Supplies manual capability data to skip probes or adjust feature flags.
+    pub fn capability_overrides(mut self, overrides: crate::CapabilityOverrides) -> Self {
+        self.capability_overrides = overrides;
+        self
+    }
+
+    /// Convenience to apply feature overrides or vendor hints without touching versions.
+    pub fn capability_feature_overrides(
+        mut self,
+        overrides: crate::CapabilityFeatureOverrides,
+    ) -> Self {
+        self.capability_overrides.features = overrides;
+        self
+    }
+
+    /// Convenience to opt into specific feature flags while leaving other probes intact.
+    pub fn capability_feature_hints(mut self, features: crate::CodexFeatureFlags) -> Self {
+        self.capability_overrides.features = crate::CapabilityFeatureOverrides::enabling(features);
+        self
+    }
+
+    /// Supplies a precomputed capability snapshot for pinned or bundled Codex builds.
+    /// Combine with `write_capabilities_snapshot` / `read_capabilities_snapshot`
+    /// to persist probe results between processes.
+    pub fn capability_snapshot(mut self, snapshot: crate::CodexCapabilities) -> Self {
+        self.capability_overrides.snapshot = Some(snapshot);
+        self
+    }
+
+    /// Overrides the probed version data with caller-provided metadata.
+    pub fn capability_version_override(mut self, version: crate::CodexVersionInfo) -> Self {
+        self.capability_overrides.version = Some(version);
+        self
+    }
+
+    /// Controls how capability probes interact with the in-process cache.
+    /// Use [`crate::CapabilityCachePolicy::Refresh`] to enforce a TTL/backoff when
+    /// binaries are hot-swapped without changing fingerprints.
+    pub fn capability_cache_policy(mut self, policy: crate::CapabilityCachePolicy) -> Self {
+        self.capability_cache_policy = policy;
+        self
+    }
+
+    /// Convenience to bypass the capability cache when a fresh snapshot is required.
+    /// Bypass skips cache reads and writes for the probe.
+    pub fn bypass_capability_cache(mut self, bypass: bool) -> Self {
+        self.capability_cache_policy = if bypass {
+            crate::CapabilityCachePolicy::Bypass
+        } else {
+            crate::CapabilityCachePolicy::PreferCache
+        };
+        self
+    }
+
+    /// Builds the [`crate::CodexClient`].
+    pub fn build(self) -> crate::CodexClient {
+        let command_env =
+            CommandEnvironment::new(self.binary, self.codex_home, self.create_home_dirs);
+        crate::CodexClient {
+            command_env,
+            model: self.model,
+            timeout: self.timeout,
+            color_mode: self.color_mode,
+            working_dir: self.working_dir,
+            add_dirs: self.add_dirs,
+            images: self.images,
+            json_output: self.json_output,
+            output_schema: self.output_schema,
+            quiet: self.quiet,
+            mirror_stdout: self.mirror_stdout,
+            json_event_log: self.json_event_log,
+            cli_overrides: self.cli_overrides,
+            capability_overrides: self.capability_overrides,
+            capability_cache_policy: self.capability_cache_policy,
+        }
+    }
+}
+
+impl Default for CodexClientBuilder {
+    fn default() -> Self {
+        Self {
+            binary: super::default_binary_path(),
+            codex_home: None,
+            create_home_dirs: true,
+            model: None,
+            timeout: super::DEFAULT_TIMEOUT,
+            color_mode: ColorMode::Never,
+            working_dir: None,
+            add_dirs: Vec::new(),
+            images: Vec::new(),
+            json_output: false,
+            output_schema: false,
+            quiet: false,
+            mirror_stdout: true,
+            json_event_log: None,
+            cli_overrides: CliOverrides::default(),
+            capability_overrides: crate::CapabilityOverrides::default(),
+            capability_cache_policy: crate::CapabilityCachePolicy::default(),
+        }
+    }
+}
+
+/// ANSI color behavior for `codex exec` output.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum ColorMode {
+    /// Match upstream defaults: use color codes when stdout/stderr look like terminals.
+    Auto,
+    /// Force colorful output even when piping.
+    Always,
+    /// Fully disable ANSI sequences for deterministic parsing/logging (default).
+    Never,
+}
+
+impl ColorMode {
+    pub(super) const fn as_str(self) -> &'static str {
+        match self {
+            ColorMode::Auto => "auto",
+            ColorMode::Always => "always",
+            ColorMode::Never => "never",
+        }
+    }
+}
+
+/// Approval policy used by `--ask-for-approval`.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum ApprovalPolicy {
+    Untrusted,
+    OnFailure,
+    OnRequest,
+    Never,
+}
+
+impl ApprovalPolicy {
+    const fn as_str(self) -> &'static str {
+        match self {
+            ApprovalPolicy::Untrusted => "untrusted",
+            ApprovalPolicy::OnFailure => "on-failure",
+            ApprovalPolicy::OnRequest => "on-request",
+            ApprovalPolicy::Never => "never",
+        }
+    }
+}
+
+/// Sandbox isolation level.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum SandboxMode {
+    ReadOnly,
+    WorkspaceWrite,
+    DangerFullAccess,
+}
+
+impl SandboxMode {
+    const fn as_str(self) -> &'static str {
+        match self {
+            SandboxMode::ReadOnly => "read-only",
+            SandboxMode::WorkspaceWrite => "workspace-write",
+            SandboxMode::DangerFullAccess => "danger-full-access",
+        }
+    }
+}
+
+/// Safety overrides that collapse approval/sandbox behavior.
+#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
+pub enum SafetyOverride {
+    #[default]
+    Inherit,
+    FullAuto,
+    DangerouslyBypass,
+}
+
+/// Local provider selection for OSS backends.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum LocalProvider {
+    LmStudio,
+    Ollama,
+    Custom,
+}
+
+impl LocalProvider {
+    const fn as_str(self) -> &'static str {
+        match self {
+            LocalProvider::LmStudio => "lmstudio",
+            LocalProvider::Ollama => "ollama",
+            LocalProvider::Custom => "custom",
+        }
+    }
+}
+
+/// Three-state flag used when requests can override builder defaults.
+#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
+pub enum FlagState {
+    #[default]
+    Inherit,
+    Enable,
+    Disable,
+}
+
+/// Feature toggles forwarded to `--enable/--disable`.
+#[derive(Clone, Debug, Default, Eq, PartialEq)]
+pub struct FeatureToggles {
+    pub enable: Vec<String>,
+    pub disable: Vec<String>,
+}
+
+/// Config values for `model_reasoning_effort`.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum ReasoningEffort {
+    Minimal,
+    Low,
+    Medium,
+    High,
+}
+
+impl ReasoningEffort {
+    const fn as_str(self) -> &'static str {
+        match self {
+            ReasoningEffort::Minimal => "minimal",
+            ReasoningEffort::Low => "low",
+            ReasoningEffort::Medium => "medium",
+            ReasoningEffort::High => "high",
+        }
+    }
+}
+
+/// Config values for `model_reasoning_summary`.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum ReasoningSummary {
+    Auto,
+    Concise,
+    Detailed,
+    None,
+}
+
+impl ReasoningSummary {
+    const fn as_str(self) -> &'static str {
+        match self {
+            ReasoningSummary::Auto => "auto",
+            ReasoningSummary::Concise => "concise",
+            ReasoningSummary::Detailed => "detailed",
+            ReasoningSummary::None => "none",
+        }
+    }
+}
+
+/// Config values for `model_verbosity`.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum ModelVerbosity {
+    Low,
+    Medium,
+    High,
+}
+
+impl ModelVerbosity {
+    const fn as_str(self) -> &'static str {
+        match self {
+            ModelVerbosity::Low => "low",
+            ModelVerbosity::Medium => "medium",
+            ModelVerbosity::High => "high",
+        }
+    }
+}
+
+/// Config values for `model_reasoning_summary_format`.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum ReasoningSummaryFormat {
+    None,
+    Experimental,
+}
+
+impl ReasoningSummaryFormat {
+    const fn as_str(self) -> &'static str {
+        match self {
+            ReasoningSummaryFormat::None => "none",
+            ReasoningSummaryFormat::Experimental => "experimental",
+        }
+    }
+}
+
+/// Represents a single `--config key=value` override.
+#[derive(Clone, Debug, Eq, PartialEq)]
+pub struct ConfigOverride {
+    pub key: String,
+    pub value: String,
+}
+
+impl ConfigOverride {
+    pub fn new(key: impl Into<String>, value: impl Into<String>) -> Self {
+        Self {
+            key: key.into(),
+            value: value.into(),
+        }
+    }
+
+    pub fn from_raw(raw: impl Into<String>) -> Self {
+        let raw = raw.into();
+        let (key, value) = raw
+            .split_once('=')
+            .map(|(key, value)| (key.to_string(), value.to_string()))
+            .unwrap_or_else(|| (raw.clone(), String::new()));
+        ConfigOverride { key, value }
+    }
+
+    fn is_reasoning_key(&self) -> bool {
+        REASONING_CONFIG_KEYS.contains(&self.key.as_str())
+    }
+}
+
+/// Structured reasoning overrides converted into config entries.
+#[derive(Clone, Debug, Default, Eq, PartialEq)]
+pub struct ReasoningOverrides {
+    pub effort: Option<ReasoningEffort>,
+    pub summary: Option<ReasoningSummary>,
+    pub verbosity: Option<ModelVerbosity>,
+    pub summary_format: Option<ReasoningSummaryFormat>,
+    pub supports_summaries: Option<bool>,
+}
+
+impl ReasoningOverrides {
+    pub(super) fn has_overrides(&self) -> bool {
+        self.effort.is_some()
+            || self.summary.is_some()
+            || self.verbosity.is_some()
+            || self.summary_format.is_some()
+            || self.supports_summaries.is_some()
+    }
+
+    fn append_overrides(&self, configs: &mut Vec<ConfigOverride>) {
+        if let Some(value) = self.effort {
+            configs.push(ConfigOverride::new("model_reasoning_effort", value.as_str()));
+        }
+        if let Some(value) = self.summary {
+            configs.push(ConfigOverride::new("model_reasoning_summary", value.as_str()));
+        }
+        if let Some(value) = self.verbosity {
+            configs.push(ConfigOverride::new("model_verbosity", value.as_str()));
+        }
+        if let Some(value) = self.summary_format {
+            configs.push(ConfigOverride::new(
+                "model_reasoning_summary_format",
+                value.as_str(),
+            ));
+        }
+        if let Some(value) = self.supports_summaries {
+            configs.push(ConfigOverride::new(
+                "model_supports_reasoning_summaries",
+                value.to_string(),
+            ));
+        }
+    }
+}
+
+/// Builder-scoped CLI overrides.
+#[derive(Clone, Debug, Eq, PartialEq)]
+pub struct CliOverrides {
+    pub config_overrides: Vec<ConfigOverride>,
+    pub feature_toggles: FeatureToggles,
+    pub reasoning: ReasoningOverrides,
+    pub approval_policy: Option<ApprovalPolicy>,
+    pub sandbox_mode: Option<SandboxMode>,
+    pub safety_override: SafetyOverride,
+    pub profile: Option<String>,
+    pub cd: Option<PathBuf>,
+    pub local_provider: Option<LocalProvider>,
+    pub oss: FlagState,
+    pub search: FlagState,
+    pub auto_reasoning_defaults: bool,
+}
+
+impl Default for CliOverrides {
+    fn default() -> Self {
+        Self {
+            config_overrides: Vec::new(),
+            feature_toggles: FeatureToggles::default(),
+            reasoning: ReasoningOverrides::default(),
+            approval_policy: None,
+            sandbox_mode: None,
+            safety_override: SafetyOverride::Inherit,
+            profile: None,
+            cd: None,
+            local_provider: None,
+            oss: FlagState::Inherit,
+            search: FlagState::Inherit,
+            auto_reasoning_defaults: true,
+        }
+    }
+}
+
+/// Request-level overlay of builder overrides.
+#[derive(Clone, Debug, Default, Eq, PartialEq)]
+pub struct CliOverridesPatch {
+    pub config_overrides: Vec<ConfigOverride>,
+    pub feature_toggles: FeatureToggles,
+    pub reasoning: ReasoningOverrides,
+    pub approval_policy: Option<ApprovalPolicy>,
+    pub sandbox_mode: Option<SandboxMode>,
+    pub safety_override: Option<SafetyOverride>,
+    pub profile: Option<String>,
+    pub cd: Option<PathBuf>,
+    pub local_provider: Option<LocalProvider>,
+    pub oss: FlagState,
+    pub search: FlagState,
+    pub auto_reasoning_defaults: Option<bool>,
+}
+
+#[derive(Clone, Debug, Eq, PartialEq)]
+pub(super) struct ResolvedCliOverrides {
+    pub(super) config_overrides: Vec<ConfigOverride>,
+    pub(super) feature_toggles: FeatureToggles,
+    pub(super) approval_policy: Option<ApprovalPolicy>,
+    pub(super) sandbox_mode: Option<SandboxMode>,
+    pub(super) safety_override: SafetyOverride,
+    pub(super) profile: Option<String>,
+    pub(super) cd: Option<PathBuf>,
+    pub(super) local_provider: Option<LocalProvider>,
+    pub(super) oss: bool,
+    pub(super) search: FlagState,
+}
+
+impl ResolvedCliOverrides {
+    fn search_enabled(&self) -> bool {
+        matches!(self.search, FlagState::Enable)
+    }
+}
+
+const REASONING_CONFIG_KEYS: &[&str] = &[
+    "model_reasoning_effort",
+    "model_reasoning_summary",
+    "model_verbosity",
+    "model_reasoning_summary_format",
+    "model_supports_reasoning_summaries",
+];
+
+pub(super) fn reasoning_config_for(
+    model: Option<&str>,
+) -> Option<&'static [(&'static str, &'static str)]> {
+    let name = model.map(|value| value.to_ascii_lowercase())?;
+    match name.as_str() {
+        name if name.starts_with("gpt-5.1-codex") => Some(DEFAULT_REASONING_CONFIG_GPT5_1),
+        name if name.starts_with("gpt-5.1") => Some(DEFAULT_REASONING_CONFIG_GPT5_1),
+        "gpt-5-codex" => Some(DEFAULT_REASONING_CONFIG_GPT5_CODEX),
+        name if name.starts_with("gpt-5") => Some(DEFAULT_REASONING_CONFIG_GPT5),
+        _ => None,
+    }
+}
+
+fn has_reasoning_config_override(overrides: &[ConfigOverride]) -> bool {
+    overrides.iter().any(ConfigOverride::is_reasoning_key)
+}
+
+pub(super) fn resolve_cli_overrides(
+    builder: &CliOverrides,
+    patch: &CliOverridesPatch,
+    model: Option<&str>,
+) -> ResolvedCliOverrides {
+    let auto_reasoning_defaults = patch
+        .auto_reasoning_defaults
+        .unwrap_or(builder.auto_reasoning_defaults);
+
+    let has_reasoning_overrides = builder.reasoning.has_overrides()
+        || patch.reasoning.has_overrides()
+        || has_reasoning_config_override(&builder.config_overrides)
+        || has_reasoning_config_override(&patch.config_overrides);
+
+    let mut config_overrides = Vec::new();
+    if auto_reasoning_defaults && !has_reasoning_overrides {
+        if let Some(defaults) = reasoning_config_for(model) {
+            for (key, value) in defaults {
+                config_overrides.push(ConfigOverride::new(*key, *value));
+            }
+        }
+    }
+
+    config_overrides.extend(builder.config_overrides.clone());
+    builder.reasoning.append_overrides(&mut config_overrides);
+    config_overrides.extend(patch.config_overrides.clone());
+    patch.reasoning.append_overrides(&mut config_overrides);
+
+    let approval_policy = patch.approval_policy.or(builder.approval_policy);
+    let sandbox_mode = patch.sandbox_mode.or(builder.sandbox_mode);
+    let safety_override = patch.safety_override.unwrap_or(builder.safety_override);
+    let profile = patch.profile.clone().or_else(|| builder.profile.clone());
+    let cd = patch.cd.clone().or_else(|| builder.cd.clone());
+    let local_provider = patch.local_provider.or(builder.local_provider);
+    let search = match patch.search {
+        FlagState::Inherit => builder.search,
+        other => other,
+    };
+    let oss = match patch.oss {
+        FlagState::Inherit => builder.oss,
+        other => other,
+    };
+    let mut feature_toggles = builder.feature_toggles.clone();
+    feature_toggles
+        .enable
+        .extend(patch.feature_toggles.enable.iter().cloned());
+    feature_toggles
+        .disable
+        .extend(patch.feature_toggles.disable.iter().cloned());
+
+    ResolvedCliOverrides {
+        config_overrides,
+        feature_toggles,
+        approval_policy,
+        sandbox_mode,
+        safety_override,
+        profile,
+        cd,
+        local_provider,
+        oss: matches!(oss, FlagState::Enable),
+        search,
+    }
+}
+
+pub(super) fn cli_override_args(
+    resolved: &ResolvedCliOverrides,
+    include_search: bool,
+) -> Vec<OsString> {
+    let mut args = Vec::new();
+    for config in &resolved.config_overrides {
+        args.push(OsString::from("--config"));
+        args.push(OsString::from(format!("{}={}", config.key, config.value)));
+    }
+
+    for feature in &resolved.feature_toggles.enable {
+        args.push(OsString::from("--enable"));
+        args.push(OsString::from(feature));
+    }
+
+    for feature in &resolved.feature_toggles.disable {
+        args.push(OsString::from("--disable"));
+        args.push(OsString::from(feature));
+    }
+
+    if let Some(profile) = &resolved.profile {
+        args.push(OsString::from("--profile"));
+        args.push(OsString::from(profile));
+    }
+
+    match resolved.safety_override {
+        SafetyOverride::DangerouslyBypass => {
+            args.push(OsString::from("--dangerously-bypass-approvals-and-sandbox"));
+        }
+        other => {
+            if let Some(policy) = resolved.approval_policy {
+                args.push(OsString::from("--ask-for-approval"));
+                args.push(OsString::from(policy.as_str()));
+            }
+
+            if let Some(mode) = resolved.sandbox_mode {
+                args.push(OsString::from("--sandbox"));
+                args.push(OsString::from(mode.as_str()));
+            } else if resolved.approval_policy.is_none() && matches!(other, SafetyOverride::FullAuto)
+            {
+                args.push(OsString::from("--full-auto"));
+            }
+        }
+    }
+
+    if let Some(cd) = &resolved.cd {
+        args.push(OsString::from("--cd"));
+        args.push(cd.as_os_str().to_os_string());
+    }
+
+    if let Some(provider) = resolved.local_provider {
+        args.push(OsString::from("--local-provider"));
+        args.push(OsString::from(provider.as_str()));
+    }
+
+    if resolved.oss {
+        args.push(OsString::from("--oss"));
+    }
+
+    if include_search && resolved.search_enabled() {
+        args.push(OsString::from("--search"));
+    }
+
+    args
+}
+
+pub(super) fn apply_cli_overrides(
+    command: &mut Command,
+    resolved: &ResolvedCliOverrides,
+    include_search: bool,
+) {
+    for arg in cli_override_args(resolved, include_search) {
+        command.arg(arg);
+    }
+}
+
diff --git a/crates/codex/src/lib.rs b/crates/codex/src/lib.rs
index de333a7..154077c 100644
--- a/crates/codex/src/lib.rs
+++ b/crates/codex/src/lib.rs
@@ -68,6 +68,7 @@
 //! - Overrides + persistence: `capability_snapshot`, `capability_overrides`, `write_capabilities_snapshot`, `read_capabilities_snapshot`, and `capability_snapshot_matches_binary` let hosts reuse snapshots across processes and fall back to probes when fingerprints diverge.
 
 mod apply_diff;
+mod builder;
 mod execpolicy;
 mod home;
 pub mod jsonl;
@@ -75,6 +76,11 @@ pub mod mcp;
 pub mod wrapper_coverage_manifest;
 
 pub use apply_diff::{ApplyDiffArtifacts, CloudApplyRequest, CloudDiffRequest};
+pub use builder::{
+    ApprovalPolicy, CliOverrides, CliOverridesPatch, CodexClientBuilder, ColorMode, ConfigOverride,
+    FeatureToggles, FlagState, LocalProvider, ModelVerbosity, ReasoningEffort, ReasoningOverrides,
+    ReasoningSummary, ReasoningSummaryFormat, SafetyOverride, SandboxMode,
+};
 pub use execpolicy::{
     ExecPolicyCheckRequest, ExecPolicyCheckResult, ExecPolicyDecision, ExecPolicyEvaluation,
     ExecPolicyMatch, ExecPolicyNoMatch, ExecPolicyRuleMatch,
@@ -100,6 +106,7 @@ use std::{
 };
 
 use futures_core::Stream;
+use builder::{apply_cli_overrides, resolve_cli_overrides};
 use home::CommandEnvironment;
 use semver::{Prerelease, Version};
 use serde::{Deserialize, Serialize};
@@ -119,28 +126,17 @@ use tokio::{
 use tracing::{debug, warn};
 
 const DEFAULT_TIMEOUT: Duration = Duration::from_secs(120);
-const DEFAULT_REASONING_CONFIG_GPT5: &[(&str, &str)] = &[
-    ("model_reasoning_effort", "medium"),
-    ("model_reasoning_summary", "auto"),
-    ("model_verbosity", "low"),
-];
-
-const DEFAULT_REASONING_CONFIG_GPT5_CODEX: &[(&str, &str)] = &[
-    ("model_reasoning_effort", "medium"),
-    ("model_reasoning_summary", "auto"),
-    ("model_verbosity", "low"),
-];
-
-const DEFAULT_REASONING_CONFIG_GPT5_1: &[(&str, &str)] = &[
-    ("model_reasoning_effort", "medium"),
-    ("model_reasoning_summary", "auto"),
-    ("model_verbosity", "low"),
-];
 const CODEX_BINARY_ENV: &str = "CODEX_BINARY";
 const CODEX_HOME_ENV: &str = "CODEX_HOME";
 const RUST_LOG_ENV: &str = "RUST_LOG";
 const DEFAULT_RUST_LOG: &str = "error";
 
+#[cfg(test)]
+use builder::{
+    cli_override_args, reasoning_config_for, DEFAULT_REASONING_CONFIG_GPT5,
+    DEFAULT_REASONING_CONFIG_GPT5_1, DEFAULT_REASONING_CONFIG_GPT5_CODEX,
+};
+
 /// Specification for resolving an app-bundled Codex binary.
 ///
 /// Callers supply a bundle root plus the pinned version they expect. Platform
@@ -2706,898 +2702,6 @@ impl Default for CodexClient {
     }
 }
 
-/// Builder for [`CodexClient`].
-///
-/// CLI parity planning and implementation history lives under `docs/project_management/next/`
-/// (see `docs/project_management/next/codex-cli-parity/`) and the parity ADRs in `docs/adr/`.
-#[derive(Clone, Debug)]
-pub struct CodexClientBuilder {
-    binary: PathBuf,
-    codex_home: Option<PathBuf>,
-    create_home_dirs: bool,
-    model: Option<String>,
-    timeout: Duration,
-    color_mode: ColorMode,
-    working_dir: Option<PathBuf>,
-    add_dirs: Vec<PathBuf>,
-    images: Vec<PathBuf>,
-    json_output: bool,
-    output_schema: bool,
-    quiet: bool,
-    mirror_stdout: bool,
-    json_event_log: Option<PathBuf>,
-    cli_overrides: CliOverrides,
-    capability_overrides: CapabilityOverrides,
-    capability_cache_policy: CapabilityCachePolicy,
-}
-
-impl CodexClientBuilder {
-    /// Starts a new builder with default values.
-    pub fn new() -> Self {
-        Self::default()
-    }
-
-    /// Sets the path to the Codex binary.
-    ///
-    /// Defaults to `CODEX_BINARY` when present or `codex` on `PATH`. Use this to pin a packaged
-    /// binary, e.g. the path returned from [`resolve_bundled_binary`] when your app ships Codex
-    /// inside an isolated bundle.
-    pub fn binary(mut self, binary: impl Into<PathBuf>) -> Self {
-        self.binary = binary.into();
-        self
-    }
-
-    /// Sets a custom `CODEX_HOME` path that will be applied per command.
-    /// Directories are created by default; disable via [`Self::create_home_dirs`].
-    pub fn codex_home(mut self, home: impl Into<PathBuf>) -> Self {
-        self.codex_home = Some(home.into());
-        self
-    }
-
-    /// Controls whether the CODEX_HOME directory tree should be created if missing.
-    /// Defaults to `true` when [`Self::codex_home`] is set.
-    pub fn create_home_dirs(mut self, enable: bool) -> Self {
-        self.create_home_dirs = enable;
-        self
-    }
-
-    /// Sets the model that should be used for every `codex exec` call.
-    pub fn model(mut self, model: impl Into<String>) -> Self {
-        let model = model.into();
-        self.model = (!model.trim().is_empty()).then_some(model);
-        self
-    }
-
-    /// Overrides the maximum amount of time to wait for Codex to respond.
-    pub fn timeout(mut self, timeout: Duration) -> Self {
-        self.timeout = timeout;
-        self
-    }
-
-    /// Controls whether Codex may emit ANSI colors (`--color`). Defaults to [`ColorMode::Never`].
-    pub fn color_mode(mut self, color_mode: ColorMode) -> Self {
-        self.color_mode = color_mode;
-        self
-    }
-
-    /// Forces Codex to run with the provided working directory instead of a fresh temp dir.
-    pub fn working_dir(mut self, dir: impl Into<PathBuf>) -> Self {
-        self.working_dir = Some(dir.into());
-        self
-    }
-
-    /// Requests that `codex exec` include one or more `--add-dir` flags when the
-    /// probed binary supports them. Unsupported or unknown capability results
-    /// skip the flag to avoid CLI errors.
-    pub fn add_dir(mut self, path: impl Into<PathBuf>) -> Self {
-        self.add_dirs.push(path.into());
-        self
-    }
-
-    /// Replaces the current add-dir list with the provided collection.
-    pub fn add_dirs<I, P>(mut self, dirs: I) -> Self
-    where
-        I: IntoIterator<Item = P>,
-        P: Into<PathBuf>,
-    {
-        self.add_dirs = dirs.into_iter().map(Into::into).collect();
-        self
-    }
-
-    /// Adds an image to the prompt by passing `--image <path>` to `codex exec`.
-    pub fn image(mut self, path: impl Into<PathBuf>) -> Self {
-        self.images.push(path.into());
-        self
-    }
-
-    /// Replaces the current image list with the provided collection.
-    pub fn images<I, P>(mut self, images: I) -> Self
-    where
-        I: IntoIterator<Item = P>,
-        P: Into<PathBuf>,
-    {
-        self.images = images.into_iter().map(Into::into).collect();
-        self
-    }
-
-    /// Enables Codex's JSONL output mode (`--json`).
-    ///
-    /// Prompts are piped via stdin when enabled. Events include `thread.started`
-    /// (or `thread.resumed` when continuing), `turn.started`/`turn.completed`/`turn.failed`,
-    /// and `item.created`/`item.updated` with `item.type` such as `agent_message` or `reasoning`.
-    /// Pair with `.mirror_stdout(false)` if you plan to parse the stream instead of just mirroring it.
-    pub fn json(mut self, enable: bool) -> Self {
-        self.json_output = enable;
-        self
-    }
-
-    /// Requests the `--output-schema` flag when the probed binary reports
-    /// support. When capability detection is inconclusive, the flag is skipped
-    /// to maintain compatibility with older releases.
-    pub fn output_schema(mut self, enable: bool) -> Self {
-        self.output_schema = enable;
-        self
-    }
-
-    /// Suppresses mirroring Codex stderr to the console.
-    pub fn quiet(mut self, enable: bool) -> Self {
-        self.quiet = enable;
-        self
-    }
-
-    /// Controls whether Codex stdout should be mirrored to the console while
-    /// also being captured. Disable this when you plan to parse JSONL output or
-    /// tee the stream to a log file (see `crates/codex/examples/stream_with_log.rs`).
-    pub fn mirror_stdout(mut self, enable: bool) -> Self {
-        self.mirror_stdout = enable;
-        self
-    }
-
-    /// Tees each JSONL event line from [`CodexClient::stream_exec`] into a log file.
-    /// Logs append to existing files, flush after each line, and create parent directories as
-    /// needed. [`ExecStreamRequest::json_event_log`] overrides this default per request.
-    pub fn json_event_log(mut self, path: impl Into<PathBuf>) -> Self {
-        self.json_event_log = Some(path.into());
-        self
-    }
-
-    /// Adds a `--config key=value` override that will be applied to every Codex invocation.
-    pub fn config_override(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
-        self.cli_overrides
-            .config_overrides
-            .push(ConfigOverride::new(key, value));
-        self
-    }
-
-    /// Adds a preformatted `--config key=value` override without parsing the input.
-    pub fn config_override_raw(mut self, raw: impl Into<String>) -> Self {
-        self.cli_overrides
-            .config_overrides
-            .push(ConfigOverride::from_raw(raw));
-        self
-    }
-
-    /// Replaces the config overrides with the provided collection.
-    pub fn config_overrides<I, K, V>(mut self, overrides: I) -> Self
-    where
-        I: IntoIterator<Item = (K, V)>,
-        K: Into<String>,
-        V: Into<String>,
-    {
-        self.cli_overrides.config_overrides = overrides
-            .into_iter()
-            .map(|(key, value)| ConfigOverride::new(key, value))
-            .collect();
-        self
-    }
-
-    /// Selects a Codex config profile (`--profile`).
-    pub fn profile(mut self, profile: impl Into<String>) -> Self {
-        let profile = profile.into();
-        self.cli_overrides.profile = (!profile.trim().is_empty()).then_some(profile);
-        self
-    }
-
-    /// Sets `model_reasoning_effort` via `--config`.
-    pub fn reasoning_effort(mut self, effort: ReasoningEffort) -> Self {
-        self.cli_overrides.reasoning.effort = Some(effort);
-        self
-    }
-
-    /// Sets `model_reasoning_summary` via `--config`.
-    pub fn reasoning_summary(mut self, summary: ReasoningSummary) -> Self {
-        self.cli_overrides.reasoning.summary = Some(summary);
-        self
-    }
-
-    /// Sets `model_verbosity` via `--config`.
-    pub fn reasoning_verbosity(mut self, verbosity: ModelVerbosity) -> Self {
-        self.cli_overrides.reasoning.verbosity = Some(verbosity);
-        self
-    }
-
-    /// Sets `model_reasoning_summary_format` via `--config`.
-    pub fn reasoning_summary_format(mut self, format: ReasoningSummaryFormat) -> Self {
-        self.cli_overrides.reasoning.summary_format = Some(format);
-        self
-    }
-
-    /// Sets `model_supports_reasoning_summaries` via `--config`.
-    pub fn supports_reasoning_summaries(mut self, enable: bool) -> Self {
-        self.cli_overrides.reasoning.supports_summaries = Some(enable);
-        self
-    }
-
-    /// Controls whether GPT-5* reasoning defaults should be injected automatically.
-    pub fn auto_reasoning_defaults(mut self, enable: bool) -> Self {
-        self.cli_overrides.auto_reasoning_defaults = enable;
-        self
-    }
-
-    /// Sets the approval policy for Codex subprocesses.
-    pub fn approval_policy(mut self, policy: ApprovalPolicy) -> Self {
-        self.cli_overrides.approval_policy = Some(policy);
-        self
-    }
-
-    /// Sets the sandbox mode for Codex subprocesses.
-    pub fn sandbox_mode(mut self, mode: SandboxMode) -> Self {
-        self.cli_overrides.sandbox_mode = Some(mode);
-        self
-    }
-
-    /// Applies the `--full-auto` safety override unless explicit sandbox/approval options are set.
-    pub fn full_auto(mut self, enable: bool) -> Self {
-        self.cli_overrides.safety_override = if enable {
-            SafetyOverride::FullAuto
-        } else {
-            SafetyOverride::Inherit
-        };
-        self
-    }
-
-    /// Applies the `--dangerously-bypass-approvals-and-sandbox` override.
-    pub fn dangerously_bypass_approvals_and_sandbox(mut self, enable: bool) -> Self {
-        self.cli_overrides.safety_override = if enable {
-            SafetyOverride::DangerouslyBypass
-        } else {
-            SafetyOverride::Inherit
-        };
-        self
-    }
-
-    /// Applies `--cd <dir>` to Codex invocations while keeping the process cwd set to `working_dir`.
-    pub fn cd(mut self, dir: impl Into<PathBuf>) -> Self {
-        self.cli_overrides.cd = Some(dir.into());
-        self
-    }
-
-    /// Selects a local provider backend (`--local-provider`).
-    pub fn local_provider(mut self, provider: LocalProvider) -> Self {
-        self.cli_overrides.local_provider = Some(provider);
-        self
-    }
-
-    /// Requests the CLI `--oss` flag to favor OSS/local backends when available.
-    pub fn oss(mut self, enable: bool) -> Self {
-        self.cli_overrides.oss = if enable {
-            FlagState::Enable
-        } else {
-            FlagState::Disable
-        };
-        self
-    }
-
-    /// Adds a `--enable <feature>` toggle to Codex invocations.
-    pub fn enable_feature(mut self, name: impl Into<String>) -> Self {
-        self.cli_overrides.feature_toggles.enable.push(name.into());
-        self
-    }
-
-    /// Adds a `--disable <feature>` toggle to Codex invocations.
-    pub fn disable_feature(mut self, name: impl Into<String>) -> Self {
-        self.cli_overrides.feature_toggles.disable.push(name.into());
-        self
-    }
-
-    /// Controls whether `--search` is passed through to Codex.
-    pub fn search(mut self, enable: bool) -> Self {
-        self.cli_overrides.search = if enable {
-            FlagState::Enable
-        } else {
-            FlagState::Disable
-        };
-        self
-    }
-
-    /// Supplies manual capability data to skip probes or adjust feature flags.
-    pub fn capability_overrides(mut self, overrides: CapabilityOverrides) -> Self {
-        self.capability_overrides = overrides;
-        self
-    }
-
-    /// Convenience to apply feature overrides or vendor hints without touching versions.
-    pub fn capability_feature_overrides(mut self, overrides: CapabilityFeatureOverrides) -> Self {
-        self.capability_overrides.features = overrides;
-        self
-    }
-
-    /// Convenience to opt into specific feature flags while leaving other probes intact.
-    pub fn capability_feature_hints(mut self, features: CodexFeatureFlags) -> Self {
-        self.capability_overrides.features = CapabilityFeatureOverrides::enabling(features);
-        self
-    }
-
-    /// Supplies a precomputed capability snapshot for pinned or bundled Codex builds.
-    /// Combine with `write_capabilities_snapshot` / `read_capabilities_snapshot`
-    /// to persist probe results between processes.
-    pub fn capability_snapshot(mut self, snapshot: CodexCapabilities) -> Self {
-        self.capability_overrides.snapshot = Some(snapshot);
-        self
-    }
-
-    /// Overrides the probed version data with caller-provided metadata.
-    pub fn capability_version_override(mut self, version: CodexVersionInfo) -> Self {
-        self.capability_overrides.version = Some(version);
-        self
-    }
-
-    /// Controls how capability probes interact with the in-process cache.
-    /// Use [`CapabilityCachePolicy::Refresh`] to enforce a TTL/backoff when
-    /// binaries are hot-swapped without changing fingerprints.
-    pub fn capability_cache_policy(mut self, policy: CapabilityCachePolicy) -> Self {
-        self.capability_cache_policy = policy;
-        self
-    }
-
-    /// Convenience to bypass the capability cache when a fresh snapshot is required.
-    /// Bypass skips cache reads and writes for the probe.
-    pub fn bypass_capability_cache(mut self, bypass: bool) -> Self {
-        self.capability_cache_policy = if bypass {
-            CapabilityCachePolicy::Bypass
-        } else {
-            CapabilityCachePolicy::PreferCache
-        };
-        self
-    }
-
-    /// Builds the [`CodexClient`].
-    pub fn build(self) -> CodexClient {
-        let command_env =
-            CommandEnvironment::new(self.binary, self.codex_home, self.create_home_dirs);
-        CodexClient {
-            command_env,
-            model: self.model,
-            timeout: self.timeout,
-            color_mode: self.color_mode,
-            working_dir: self.working_dir,
-            add_dirs: self.add_dirs,
-            images: self.images,
-            json_output: self.json_output,
-            output_schema: self.output_schema,
-            quiet: self.quiet,
-            mirror_stdout: self.mirror_stdout,
-            json_event_log: self.json_event_log,
-            cli_overrides: self.cli_overrides,
-            capability_overrides: self.capability_overrides,
-            capability_cache_policy: self.capability_cache_policy,
-        }
-    }
-}
-
-impl Default for CodexClientBuilder {
-    fn default() -> Self {
-        Self {
-            binary: default_binary_path(),
-            codex_home: None,
-            create_home_dirs: true,
-            model: None,
-            timeout: DEFAULT_TIMEOUT,
-            color_mode: ColorMode::Never,
-            working_dir: None,
-            add_dirs: Vec::new(),
-            images: Vec::new(),
-            json_output: false,
-            output_schema: false,
-            quiet: false,
-            mirror_stdout: true,
-            json_event_log: None,
-            cli_overrides: CliOverrides::default(),
-            capability_overrides: CapabilityOverrides::default(),
-            capability_cache_policy: CapabilityCachePolicy::default(),
-        }
-    }
-}
-
-/// ANSI color behavior for `codex exec` output.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum ColorMode {
-    /// Match upstream defaults: use color codes when stdout/stderr look like terminals.
-    Auto,
-    /// Force colorful output even when piping.
-    Always,
-    /// Fully disable ANSI sequences for deterministic parsing/logging (default).
-    Never,
-}
-
-impl ColorMode {
-    const fn as_str(self) -> &'static str {
-        match self {
-            ColorMode::Auto => "auto",
-            ColorMode::Always => "always",
-            ColorMode::Never => "never",
-        }
-    }
-}
-
-/// Approval policy used by `--ask-for-approval`.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum ApprovalPolicy {
-    Untrusted,
-    OnFailure,
-    OnRequest,
-    Never,
-}
-
-impl ApprovalPolicy {
-    const fn as_str(self) -> &'static str {
-        match self {
-            ApprovalPolicy::Untrusted => "untrusted",
-            ApprovalPolicy::OnFailure => "on-failure",
-            ApprovalPolicy::OnRequest => "on-request",
-            ApprovalPolicy::Never => "never",
-        }
-    }
-}
-
-/// Sandbox isolation level.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum SandboxMode {
-    ReadOnly,
-    WorkspaceWrite,
-    DangerFullAccess,
-}
-
-impl SandboxMode {
-    const fn as_str(self) -> &'static str {
-        match self {
-            SandboxMode::ReadOnly => "read-only",
-            SandboxMode::WorkspaceWrite => "workspace-write",
-            SandboxMode::DangerFullAccess => "danger-full-access",
-        }
-    }
-}
-
-/// Safety overrides that collapse approval/sandbox behavior.
-#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
-pub enum SafetyOverride {
-    #[default]
-    Inherit,
-    FullAuto,
-    DangerouslyBypass,
-}
-
-/// Local provider selection for OSS backends.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum LocalProvider {
-    LmStudio,
-    Ollama,
-    Custom,
-}
-
-impl LocalProvider {
-    const fn as_str(self) -> &'static str {
-        match self {
-            LocalProvider::LmStudio => "lmstudio",
-            LocalProvider::Ollama => "ollama",
-            LocalProvider::Custom => "custom",
-        }
-    }
-}
-
-/// Three-state flag used when requests can override builder defaults.
-#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
-pub enum FlagState {
-    #[default]
-    Inherit,
-    Enable,
-    Disable,
-}
-
-/// Feature toggles forwarded to `--enable/--disable`.
-#[derive(Clone, Debug, Default, Eq, PartialEq)]
-pub struct FeatureToggles {
-    pub enable: Vec<String>,
-    pub disable: Vec<String>,
-}
-
-/// Config values for `model_reasoning_effort`.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum ReasoningEffort {
-    Minimal,
-    Low,
-    Medium,
-    High,
-}
-
-impl ReasoningEffort {
-    const fn as_str(self) -> &'static str {
-        match self {
-            ReasoningEffort::Minimal => "minimal",
-            ReasoningEffort::Low => "low",
-            ReasoningEffort::Medium => "medium",
-            ReasoningEffort::High => "high",
-        }
-    }
-}
-
-/// Config values for `model_reasoning_summary`.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum ReasoningSummary {
-    Auto,
-    Concise,
-    Detailed,
-    None,
-}
-
-impl ReasoningSummary {
-    const fn as_str(self) -> &'static str {
-        match self {
-            ReasoningSummary::Auto => "auto",
-            ReasoningSummary::Concise => "concise",
-            ReasoningSummary::Detailed => "detailed",
-            ReasoningSummary::None => "none",
-        }
-    }
-}
-
-/// Config values for `model_verbosity`.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum ModelVerbosity {
-    Low,
-    Medium,
-    High,
-}
-
-impl ModelVerbosity {
-    const fn as_str(self) -> &'static str {
-        match self {
-            ModelVerbosity::Low => "low",
-            ModelVerbosity::Medium => "medium",
-            ModelVerbosity::High => "high",
-        }
-    }
-}
-
-/// Config values for `model_reasoning_summary_format`.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum ReasoningSummaryFormat {
-    None,
-    Experimental,
-}
-
-impl ReasoningSummaryFormat {
-    const fn as_str(self) -> &'static str {
-        match self {
-            ReasoningSummaryFormat::None => "none",
-            ReasoningSummaryFormat::Experimental => "experimental",
-        }
-    }
-}
-
-/// Represents a single `--config key=value` override.
-#[derive(Clone, Debug, Eq, PartialEq)]
-pub struct ConfigOverride {
-    pub key: String,
-    pub value: String,
-}
-
-impl ConfigOverride {
-    pub fn new(key: impl Into<String>, value: impl Into<String>) -> Self {
-        Self {
-            key: key.into(),
-            value: value.into(),
-        }
-    }
-
-    pub fn from_raw(raw: impl Into<String>) -> Self {
-        let raw = raw.into();
-        let (key, value) = raw
-            .split_once('=')
-            .map(|(key, value)| (key.to_string(), value.to_string()))
-            .unwrap_or_else(|| (raw.clone(), String::new()));
-        ConfigOverride { key, value }
-    }
-
-    fn is_reasoning_key(&self) -> bool {
-        REASONING_CONFIG_KEYS.contains(&self.key.as_str())
-    }
-}
-
-/// Structured reasoning overrides converted into config entries.
-#[derive(Clone, Debug, Default, Eq, PartialEq)]
-pub struct ReasoningOverrides {
-    pub effort: Option<ReasoningEffort>,
-    pub summary: Option<ReasoningSummary>,
-    pub verbosity: Option<ModelVerbosity>,
-    pub summary_format: Option<ReasoningSummaryFormat>,
-    pub supports_summaries: Option<bool>,
-}
-
-impl ReasoningOverrides {
-    fn has_overrides(&self) -> bool {
-        self.effort.is_some()
-            || self.summary.is_some()
-            || self.verbosity.is_some()
-            || self.summary_format.is_some()
-            || self.supports_summaries.is_some()
-    }
-
-    fn append_overrides(&self, configs: &mut Vec<ConfigOverride>) {
-        if let Some(value) = self.effort {
-            configs.push(ConfigOverride::new(
-                "model_reasoning_effort",
-                value.as_str(),
-            ));
-        }
-        if let Some(value) = self.summary {
-            configs.push(ConfigOverride::new(
-                "model_reasoning_summary",
-                value.as_str(),
-            ));
-        }
-        if let Some(value) = self.verbosity {
-            configs.push(ConfigOverride::new("model_verbosity", value.as_str()));
-        }
-        if let Some(value) = self.summary_format {
-            configs.push(ConfigOverride::new(
-                "model_reasoning_summary_format",
-                value.as_str(),
-            ));
-        }
-        if let Some(value) = self.supports_summaries {
-            configs.push(ConfigOverride::new(
-                "model_supports_reasoning_summaries",
-                value.to_string(),
-            ));
-        }
-    }
-}
-
-/// Builder-scoped CLI overrides.
-#[derive(Clone, Debug, Eq, PartialEq)]
-pub struct CliOverrides {
-    pub config_overrides: Vec<ConfigOverride>,
-    pub feature_toggles: FeatureToggles,
-    pub reasoning: ReasoningOverrides,
-    pub approval_policy: Option<ApprovalPolicy>,
-    pub sandbox_mode: Option<SandboxMode>,
-    pub safety_override: SafetyOverride,
-    pub profile: Option<String>,
-    pub cd: Option<PathBuf>,
-    pub local_provider: Option<LocalProvider>,
-    pub oss: FlagState,
-    pub search: FlagState,
-    pub auto_reasoning_defaults: bool,
-}
-
-impl Default for CliOverrides {
-    fn default() -> Self {
-        Self {
-            config_overrides: Vec::new(),
-            feature_toggles: FeatureToggles::default(),
-            reasoning: ReasoningOverrides::default(),
-            approval_policy: None,
-            sandbox_mode: None,
-            safety_override: SafetyOverride::Inherit,
-            profile: None,
-            cd: None,
-            local_provider: None,
-            oss: FlagState::Inherit,
-            search: FlagState::Inherit,
-            auto_reasoning_defaults: true,
-        }
-    }
-}
-
-/// Request-level overlay of builder overrides.
-#[derive(Clone, Debug, Default, Eq, PartialEq)]
-pub struct CliOverridesPatch {
-    pub config_overrides: Vec<ConfigOverride>,
-    pub feature_toggles: FeatureToggles,
-    pub reasoning: ReasoningOverrides,
-    pub approval_policy: Option<ApprovalPolicy>,
-    pub sandbox_mode: Option<SandboxMode>,
-    pub safety_override: Option<SafetyOverride>,
-    pub profile: Option<String>,
-    pub cd: Option<PathBuf>,
-    pub local_provider: Option<LocalProvider>,
-    pub oss: FlagState,
-    pub search: FlagState,
-    pub auto_reasoning_defaults: Option<bool>,
-}
-
-#[derive(Clone, Debug, Eq, PartialEq)]
-struct ResolvedCliOverrides {
-    config_overrides: Vec<ConfigOverride>,
-    feature_toggles: FeatureToggles,
-    approval_policy: Option<ApprovalPolicy>,
-    sandbox_mode: Option<SandboxMode>,
-    safety_override: SafetyOverride,
-    profile: Option<String>,
-    cd: Option<PathBuf>,
-    local_provider: Option<LocalProvider>,
-    oss: bool,
-    search: FlagState,
-}
-
-impl ResolvedCliOverrides {
-    fn search_enabled(&self) -> bool {
-        matches!(self.search, FlagState::Enable)
-    }
-}
-
-const REASONING_CONFIG_KEYS: &[&str] = &[
-    "model_reasoning_effort",
-    "model_reasoning_summary",
-    "model_verbosity",
-    "model_reasoning_summary_format",
-    "model_supports_reasoning_summaries",
-];
-
-fn reasoning_config_for(model: Option<&str>) -> Option<&'static [(&'static str, &'static str)]> {
-    let name = model.map(|value| value.to_ascii_lowercase())?;
-    match name.as_str() {
-        name if name.starts_with("gpt-5.1-codex") => Some(DEFAULT_REASONING_CONFIG_GPT5_1),
-        name if name.starts_with("gpt-5.1") => Some(DEFAULT_REASONING_CONFIG_GPT5_1),
-        "gpt-5-codex" => Some(DEFAULT_REASONING_CONFIG_GPT5_CODEX),
-        name if name.starts_with("gpt-5") => Some(DEFAULT_REASONING_CONFIG_GPT5),
-        _ => None,
-    }
-}
-
-fn has_reasoning_config_override(overrides: &[ConfigOverride]) -> bool {
-    overrides.iter().any(ConfigOverride::is_reasoning_key)
-}
-
-fn resolve_cli_overrides(
-    builder: &CliOverrides,
-    patch: &CliOverridesPatch,
-    model: Option<&str>,
-) -> ResolvedCliOverrides {
-    let auto_reasoning_defaults = patch
-        .auto_reasoning_defaults
-        .unwrap_or(builder.auto_reasoning_defaults);
-
-    let has_reasoning_overrides = builder.reasoning.has_overrides()
-        || patch.reasoning.has_overrides()
-        || has_reasoning_config_override(&builder.config_overrides)
-        || has_reasoning_config_override(&patch.config_overrides);
-
-    let mut config_overrides = Vec::new();
-    if auto_reasoning_defaults && !has_reasoning_overrides {
-        if let Some(defaults) = reasoning_config_for(model) {
-            for (key, value) in defaults {
-                config_overrides.push(ConfigOverride::new(*key, *value));
-            }
-        }
-    }
-
-    config_overrides.extend(builder.config_overrides.clone());
-    builder.reasoning.append_overrides(&mut config_overrides);
-    config_overrides.extend(patch.config_overrides.clone());
-    patch.reasoning.append_overrides(&mut config_overrides);
-
-    let approval_policy = patch.approval_policy.or(builder.approval_policy);
-    let sandbox_mode = patch.sandbox_mode.or(builder.sandbox_mode);
-    let safety_override = patch.safety_override.unwrap_or(builder.safety_override);
-    let profile = patch.profile.clone().or_else(|| builder.profile.clone());
-    let cd = patch.cd.clone().or_else(|| builder.cd.clone());
-    let local_provider = patch.local_provider.or(builder.local_provider);
-    let search = match patch.search {
-        FlagState::Inherit => builder.search,
-        other => other,
-    };
-    let oss = match patch.oss {
-        FlagState::Inherit => builder.oss,
-        other => other,
-    };
-    let mut feature_toggles = builder.feature_toggles.clone();
-    feature_toggles
-        .enable
-        .extend(patch.feature_toggles.enable.iter().cloned());
-    feature_toggles
-        .disable
-        .extend(patch.feature_toggles.disable.iter().cloned());
-
-    ResolvedCliOverrides {
-        config_overrides,
-        feature_toggles,
-        approval_policy,
-        sandbox_mode,
-        safety_override,
-        profile,
-        cd,
-        local_provider,
-        oss: matches!(oss, FlagState::Enable),
-        search,
-    }
-}
-
-fn cli_override_args(resolved: &ResolvedCliOverrides, include_search: bool) -> Vec<OsString> {
-    let mut args = Vec::new();
-    for config in &resolved.config_overrides {
-        args.push(OsString::from("--config"));
-        args.push(OsString::from(format!("{}={}", config.key, config.value)));
-    }
-
-    for feature in &resolved.feature_toggles.enable {
-        args.push(OsString::from("--enable"));
-        args.push(OsString::from(feature));
-    }
-
-    for feature in &resolved.feature_toggles.disable {
-        args.push(OsString::from("--disable"));
-        args.push(OsString::from(feature));
-    }
-
-    if let Some(profile) = &resolved.profile {
-        args.push(OsString::from("--profile"));
-        args.push(OsString::from(profile));
-    }
-
-    match resolved.safety_override {
-        SafetyOverride::DangerouslyBypass => {
-            args.push(OsString::from("--dangerously-bypass-approvals-and-sandbox"));
-        }
-        other => {
-            if let Some(policy) = resolved.approval_policy {
-                args.push(OsString::from("--ask-for-approval"));
-                args.push(OsString::from(policy.as_str()));
-            }
-
-            if let Some(mode) = resolved.sandbox_mode {
-                args.push(OsString::from("--sandbox"));
-                args.push(OsString::from(mode.as_str()));
-            } else if resolved.approval_policy.is_none()
-                && matches!(other, SafetyOverride::FullAuto)
-            {
-                args.push(OsString::from("--full-auto"));
-            }
-        }
-    }
-
-    if let Some(cd) = &resolved.cd {
-        args.push(OsString::from("--cd"));
-        args.push(cd.as_os_str().to_os_string());
-    }
-
-    if let Some(provider) = resolved.local_provider {
-        args.push(OsString::from("--local-provider"));
-        args.push(OsString::from(provider.as_str()));
-    }
-
-    if resolved.oss {
-        args.push(OsString::from("--oss"));
-    }
-
-    if include_search && resolved.search_enabled() {
-        args.push(OsString::from("--search"));
-    }
-
-    args
-}
-
-fn apply_cli_overrides(
-    command: &mut Command,
-    resolved: &ResolvedCliOverrides,
-    include_search: bool,
-) {
-    for arg in cli_override_args(resolved, include_search) {
-        command.arg(arg);
-    }
-}
-
 fn spawn_with_retry(
     command: &mut Command,
     binary: &Path,
